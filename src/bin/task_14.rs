fn main() {
    // Здесь мы создаем канал с помощью функции std::sync::mpsc::channel(). Этот канал позволяет передавать данные между потоками.
    // mpsc в Rust обозначает "multi-producer, single-consumer" (много производителей, один потребитель)
    // tx — это отправитель (transmitter), который будет использоваться для отправки данных в канал.
    // rv — это получатель (receiver), который будет использоваться для получения данных из канала.
    // ::<i32> указывает, что канал будет передавать значения типа i32.
    let (tx, rv) = std::sync::mpsc::channel::<i32>();

    // Здесь мы создаем новый поток с помощью std::thread::spawn(). Внутри этого потока выполняется замыкание (closure), которое отправляет числа от 0 до 9 в канал.
    // move указывает, что замыкание захватывает переменные из окружающей среды, передавая их в новый поток. В данном случае, это переменная tx.
    let handle = std::thread::spawn(move || {
        // Цикл для заначений от 0 до 9, можно использовать другой синтаксис - for i in 0..=9, но он работает медленнее, пару раз натыкался на такой момент
        for i in 0..10 {
            // отправляем значения i в канал с помощью tx.send(i). Метод send возвращает Result, поэтому мы вызываем unwrap()
            tx.send(i).unwrap();
        }
    });

    // вызываем join() на handle, чтобы дождаться завершения потока.
    // Это гарантирует, что основной поток (где выполняется main) не завершится до тех пор,
    // пока дочерний поток не завершит свою работу.
    handle.join().unwrap();

    // После завершения потока мы начинаем получать данные из канала с помощью rv.iter() - используем &self.
    // Этот метод возвращает итератор, который будет получать значения, отправленные в канал (внутри вызывается .next(), пока Some(val)).
    for i in rv.iter() {
        // выводим каждое полученное значение на экран с помощью println!("{i:?}"). Спецификатор :? используется для отладочного вывода
        println!("{i:?}");
    }
}
